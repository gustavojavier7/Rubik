<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Juego de Cubo de Rubik 3D con Bot</title>
  <style>
    body { margin: 0; background: #f0f0f0; font-family: Arial, sans-serif; }
    #canvasContainer { width: 100vw; height: 70vh; display: flex; justify-content: center; align-items: center; }
    #controls { text-align: center; padding: 10px; }
    #controls select, #controls button { margin: 5px; padding: 5px; font-size: 16px; }
    #status { margin-top: 10px; font-size: 18px; }
  </style>
</head>
<body>
  <div id="canvasContainer">
    <div>Arrastra con el rat贸n para girar el cubo 路 Usa la rueda para hacer zoom 路 Powered by Canvas</div>
  </div>
  <div id="controls">
    <div>
      Seleccionar Cara para Animaci贸n:
      <select id="faceSelect">
        <option value="F">Front (F)</option>
        <option value="B">Back (B)</option>
        <option value="L">Left (L)</option>
        <option value="R">Right (R)</option>
        <option value="U">Up (U)</option>
        <option value="D">Down (D)</option>
      </select>
    </div>
    <div>
      Movimientos de Cara:
      <button onclick="makeMove('U')">U</button>
      <button onclick="makeMove('U\'')">U'</button>
      <button onclick="makeMove('D')">D</button>
      <button onclick="makeMove('D\'')">D'</button>
      <button onclick="makeMove('L')">L</button>
      <button onclick="makeMove('L\'')">L'</button>
      <button onclick="makeMove('R')">R</button>
      <button onclick="makeMove('R\'')">R'</button>
      <button onclick="makeMove('F')">F</button>
      <button onclick="makeMove('F\'')">F'</button>
      <button onclick="makeMove('B')">B</button>
      <button onclick="makeMove('B\'')">B'</button>
    </div>
    <div>
      Movimientos de Capa Media:
      <button onclick="makeMove('M')">M</button>
      <button onclick="makeMove('M\'')">M'</button>
      <button onclick="makeMove('E')">E</button>
      <button onclick="makeMove('E\'')">E'</button>
      <button onclick="makeMove('S')">S</button>
      <button onclick="makeMove('S\'')">S'</button>
    </div>
    <div>
      Rotaciones de Cubo Completo:
      <button onclick="makeMove('x')">x</button>
      <button onclick="makeMove('x\'')">x'</button>
      <button onclick="makeMove('y')">y</button>
      <button onclick="makeMove('y\'')">y'</button>
      <button onclick="makeMove('z')">z</button>
      <button onclick="makeMove('z\'')">z'</button>
    </div>
    <div>
      <button onclick="startBot()">Iniciar Bot</button>
      <button onclick="scrambleCube()">Mezclar Cubo</button>
    </div>
    <div id="status">Cubo listo</div>
  </div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script>
var scene, camera, renderer, cubeGroup, isAnimating = false;
var cubeState = [];
var moveQueue = [];
var DEMO_MODE = false;

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(5, 5, 5);
  camera.lookAt(0, 0, 0);
  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight * 0.7);
  document.getElementById('canvasContainer').appendChild(renderer.domElement);

  cubeGroup = new THREE.Group();
  scene.add(cubeGroup);
  initializeCube();
  setupControls();
  animate();
}

function initializeCube() {
  cubeState = [];
  const colors = {
    U: 0xffffff, // Blanco
    D: 0xffff00, // Amarillo
    F: 0x00ff00, // Verde
    B: 0x0000ff, // Azul
    L: 0xffa500, // Naranja
    R: 0xff0000  // Rojo
  };
  for (let x = -1; x <= 1; x++) {
    for (let y = -1; y <= 1; y++) {
      for (let z = -1; z <= 1; z++) {
        const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
        const materials = [
          new THREE.MeshBasicMaterial({ color: x === 1 ? colors.R : 0x000000 }),
          new THREE.MeshBasicMaterial({ color: x === -1 ? colors.L : 0x000000 }),
          new THREE.MeshBasicMaterial({ color: y === 1 ? colors.U : 0x000000 }),
          new THREE.MeshBasicMaterial({ color: y === -1 ? colors.D : 0x000000 }),
          new THREE.MeshBasicMaterial({ color: z === 1 ? colors.F : 0x000000 }),
          new THREE.MeshBasicMaterial({ color: z === -1 ? colors.B : 0x000000 })
        ];
        const cube = new THREE.Mesh(geometry, materials);
        cube.position.set(x, y, z);
        cubeGroup.add(cube);
        cubeState.push({ position: { x, y, z }, colors: materials.map(m => m.color.getHex()) });
      }
    }
  }
}

function setupControls() {
  let isDragging = false, previousMousePosition = { x: 0, y: 0 };
  document.addEventListener('mousedown', (e) => {
    isDragging = true;
    previousMousePosition = { x: e.clientX, y: e.clientY };
  });
  document.addEventListener('mousemove', (e) => {
    if (isDragging && !isAnimating) {
      const deltaMove = {
        x: e.clientX - previousMousePosition.x,
        y: e.clientY - previousMousePosition.y
      };
      cubeGroup.rotation.y += deltaMove.x * 0.005;
      cubeGroup.rotation.x += deltaMove.y * 0.005;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    }
  });
  document.addEventListener('mouseup', () => { isDragging = false; });
  document.addEventListener('wheel', (e) => {
    camera.position.z += e.deltaY * 0.01;
    camera.position.z = Math.max(3, Math.min(10, camera.position.z));
  });
}

function animate() {
  requestAnimationFrame(animate);
  if (moveQueue.length > 0 && !isAnimating) {
    executeMove(moveQueue.shift());
  }
  renderer.render(scene, camera);
}

function makeMove(move) {
  if (!isAnimating) {
    moveQueue.push(move);
  }
}

function executeMove(move) {
  isAnimating = true;
  const axisMap = {
    U: { axis: 'y', value: 1 }, D: { axis: 'y', value: -1 },
    F: { axis: 'z', value: 1 }, B: { axis: 'z', value: -1 },
    L: { axis: 'x', value: -1 }, R: { axis: 'x', value: 1 },
    M: { axis: 'x', value: 0 }, E: { axis: 'y', value: 0 },
    S: { axis: 'z', value: 0 }, x: { axis: 'x', cube: true },
    y: { axis: 'y', cube: true }, z: { axis: 'z', cube: true }
  };
  const moveInfo = axisMap[move.replace("'", "")];
  const isReverse = move.includes("'");
  const angle = isReverse ? -Math.PI / 2 : Math.PI / 2;
  const cubesToRotate = moveInfo.cube ? cubeGroup.children : cubeState
    .filter(cube => Math.abs(cube.position[moveInfo.axis] - moveInfo.value) < 0.1)
    .map(cube => cubeGroup.children[cubeState.indexOf(cube)]);
  
  let t = 0;
  const animateRotation = () => {
    t += 0.05;
    const currentAngle = angle * t;
    cubesToRotate.forEach(cube => {
      if (moveInfo.cube) {
        cubeGroup.rotation[moveInfo.axis] = currentAngle;
      } else {
        const pos = cube.position.clone();
        if (moveInfo.axis === 'x') {
          cube.position.y = pos.y * Math.cos(currentAngle) - pos.z * Math.sin(currentAngle);
          cube.position.z = pos.y * Math.sin(currentAngle) + pos.z * Math.cos(currentAngle);
          cube.rotation.x += currentAngle - (cube.rotation.x % (Math.PI / 2));
        } else if (moveInfo.axis === 'y') {
          cube.position.x = pos.x * Math.cos(currentAngle) + pos.z * Math.sin(currentAngle);
          cube.position.z = -pos.x * Math.sin(currentAngle) + pos.z * Math.cos(currentAngle);
          cube.rotation.y += currentAngle - (cube.rotation.y % (Math.PI / 2));
        } else {
          cube.position.x = pos.x * Math.cos(currentAngle) - pos.y * Math.sin(currentAngle);
          cube.position.y = pos.x * Math.sin(currentAngle) + pos.y * Math.cos(currentAngle);
          cube.rotation.z += currentAngle - (cube.rotation.z % (Math.PI / 2));
        }
      }
    });
    if (t >= 1) {
      cubesToRotate.forEach(cube => {
        cube.position[moveInfo.axis] = Math.round(cube.position[moveInfo.axis] * 100) / 100;
        if (moveInfo.axis === 'x') {
          cube.position.y = Math.round(cube.position.y * 100) / 100;
          cube.position.z = Math.round(cube.position.z * 100) / 100;
        } else if (moveInfo.axis === 'y') {
          cube.position.x = Math.round(cube.position.x * 100) / 100;
          cube.position.z = Math.round(cube.position.z * 100) / 100;
        } else {
          cube.position.x = Math.round(cube.position.x * 100) / 100;
          cube.position.y = Math.round(cube.position.y * 100) / 100;
        }
      });
      updateCubeState();
      isAnimating = false;
    } else {
      requestAnimationFrame(animateRotation);
    }
  };
  animateRotation();
}

function updateCubeState() {
  cubeState = cubeGroup.children.map(cube => ({
    position: { x: cube.position.x, y: cube.position.y, z: cube.position.z },
    colors: cube.material.map(m => m.color.getHex())
  }));
}

function scrambleCube() {
  const moves = ["U", "U'", "D", "D'", "L", "L'", "R", "R'", "F", "F'", "B", "B'"];
  for (let i = 0; i < 20; i++) {
    moveQueue.push(moves[Math.floor(Math.random() * moves.length)]);
  }
  document.getElementById('status').textContent = 'Cubo mezclado';
}

function evaluateCubeState() {
  let score = 0;
  const targetColors = {
    U: 0xffffff, D: 0xffff00, F: 0x00ff00, B: 0x0000ff, L: 0xffa500, R: 0xff0000
  };
  for (let cube of cubeState) {
    if (cube.position.y === 1 && cube.colors[2] === targetColors.U) score++;
    if (cube.position.y === -1 && cube.colors[3] === targetColors.D) score++;
    if (cube.position.z === 1 && cube.colors[4] === targetColors.F) score++;
    if (cube.position.z === -1 && cube.colors[5] === targetColors.B) score++;
    if (cube.position.x === -1 && cube.colors[1] === targetColors.L) score++;
    if (cube.position.x === 1 && cube.colors[0] === targetColors.R) score++;
  }
  return score;
}

function bestMove() {
  const moves = ["U", "U'", "D", "D'", "L", "L'", "R", "R'", "F", "F'", "B", "B'"];
  let bestScore = -Infinity, bestMove = null;
  for (let move of moves) {
    const tempState = cubeState.map(cube => ({
      position: { ...cube.position },
      colors: [...cube.colors]
    }));
    moveQueue = [move];
    executeMove(move);
    const score = evaluateCubeState();
    cubeState = tempState;
    updateCubeState();
    if (score > bestScore) {
      bestScore = score;
      bestMove = move;
    }
  }
  return bestMove;
}

function startBot() {
  if (DEMO_MODE) return;
  DEMO_MODE = true;
  document.getElementById('status').textContent = 'Bot resolviendo...';
  function botLoop() {
    if (!DEMO_MODE || evaluateCubeState() === 54) {
      DEMO_MODE = false;
      document.getElementById('status').textContent = '隆Cubo resuelto!';
      return;
    }
    const move = bestMove();
    if (move) {
      makeMove(move);
      setTimeout(botLoop, isAnimating ? 600 : 100);
    }
  }
  botLoop();
}

window.onload = init;
</script>
</body>
</html>
