<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cubo Rubik - V1.8</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body, html {
      background: #111;
      color: #fff;
      font-family: Arial, Helvetica, sans-serif;
      height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    #info {
      position: fixed;
      top: 10px;
      left: 10px;
      padding: 8px 12px;
      background: rgba(0,0,0,0.6);
      border-radius: 8px;
      font-size: 14px;
    }
    a {
      color: #08f;
      text-decoration: none;
    }
    #controls-container {
      position: fixed;
      top: 40px;
      left: 10px;
      padding: 10px;
      background: rgba(0,0,0,0.6);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 80vh;
      overflow-y: auto;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .control-group label {
      font-size: 14px;
      margin-bottom: 5px;
    }
    .control-group select, .control-group button {
      padding: 5px 10px;
      margin: 2px;
      background: rgba(255,255,255,0.1);
      border: none;
      border-radius: 3px;
      color: #fff;
      font-family: Arial;
      font-size: 14px;
      cursor: pointer;
    }
    .control-group button:hover {
      background: rgba(255,255,255,0.2);
    }
    .control-group select {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.3);
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      padding-right: 25px;
      background-image: url('data:image/svg+xml;utf8,<svg fill="%23ffffff" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
      background-repeat: no-repeat;
      background-position: right 5px center;
      background-size: 16px;
    }
    .control-group select:focus {
      outline: none;
      border-color: #08f;
    }
    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }
    h1 {
      text-align: center;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <h1 id="version-title">Cubo Rubik - V1.8</h1>
  <div id="info">
    Arrastra con el ratón para girar el cubo · Usa la rueda para hacer <em>zoom</em> · Powered by Canvas
  </div>
  <div id="controls-container">
    <div class="control-group">
      <label for="faceSelector">Seleccionar Cara para Animación:</label>
      <select id="faceSelector">
        <option value="front">Front (F)</option>
        <option value="back">Back (B)</option>
        <option value="left">Left (L)</option>
        <option value="right">Right (R)</option>
        <option value="up">Up (U)</option>
        <option value="down">Down (D)</option>
      </select>
    </div>
    <div class="control-group">
      <label>Movimientos de Cara:</label>
      <div class="button-row">
        <button data-move="U">U</button>
        <button data-move="U_prime">U'</button>
        <button data-move="D">D</button>
        <button data-move="D_prime">D'</button>
        <button data-move="L">L</button>
        <button data-move="L_prime">L'</button>
        <button data-move="R">R</button>
        <button data-move="R_prime">R'</button>
        <button data-move="F">F</button>
        <button data-move="F_prime">F'</button>
        <button data-move="B">B</button>
        <button data-move="B_prime">B'</button>
      </div>
    </div>
    <div class="control-group">
      <label>Movimientos de Capa Media:</label>
      <div class="button-row">
        <button data-move="M">M</button>
        <button data-move="M_prime">M'</button>
        <button data-move="E">E</button>
        <button data-move="E_prime">E'</button>
        <button data-move="S">S</button>
        <button data-move="S_prime">S'</button>
      </div>
    </div>
    <div class="control-group">
      <label>Rotaciones de Cubo Completo:</label>
      <div class="button-row">
        <button data-move="x">x</button>
        <button data-move="x_prime">x'</button>
        <button data-move="y">y</button>
        <button data-move="y_prime">y'</button>
        <button data-move="z">z</button>
        <button data-move="z_prime">z'</button>
      </div>
    </div>
  </div>
  <canvas id="canvas"></canvas>
  <script>
    window.addEventListener('load', () => {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const faceSelector = document.getElementById('faceSelector');
      const controlsContainer = document.getElementById('controls-container');
      
      // Ajustar tamaño del canvas
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // Definir lugares de la grilla 3×3
      const lugares = ['TL', 'TC', 'TR', 'ML', 'MC', 'MR', 'BL', 'BC', 'BR'];

      // Estado lógico del cubo
      const estadoCubo = {
        front: lugares.map(lugar => ({ color: '#00ff00', lugar })), // Verde
        back: lugares.map(lugar => ({ color: '#0000ff', lugar })),  // Azul
        left: lugares.map(lugar => ({ color: '#ffa500', lugar })),  // Naranja
        right: lugares.map(lugar => ({ color: '#ff0000', lugar })), // Rojo
        up: lugares.map(lugar => ({ color: '#ffffff', lugar })),    // Blanco
        down: lugares.map(lugar => ({ color: '#ffff00', lugar }))   // Amarillo
      };

      // Definir vectores normales base de cada cara
      const normalesOriginales = {
        front: [0, 0, 1],
        back: [0, 0, -1],
        left: [-1, 0, 0],
        right: [1, 0, 0],
        up: [0, 1, 0],
        down: [0, -1, 0]
      };

      // Definir ángulos objetivo para cada cara
      const angulosObjetivo = {
        front: { rotationX: 0, rotationY: 0 },
        back: { rotationX: 0, rotationY: Math.PI },
        left: { rotationX: 0, rotationY: -Math.PI / 2 },
        right: { rotationX: 0, rotationY: Math.PI / 2 },
        up: { rotationX: -Math.PI / 2, rotationY: 0 },
        down: { rotationX: Math.PI / 2, rotationY: 0 }
      };

      // Definir vértices de un cubo (coordenadas 3D)
      const vertices = [
        [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1], // Cara trasera
        [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]      // Cara delantera
      ];

      // Definir caras del cubo (índices de vértices, colores y nombre)
      const faces = [
        { indices: [0, 1, 2, 3], color: '#0000ff', name: 'back' },  // Atrás (azul)
        { indices: [4, 5, 6, 7], color: '#00ff00', name: 'front' }, // Frente (verde)
        { indices: [0, 1, 5, 4], color: '#ffa500', name: 'left' },  // Izquierda (naranja)
        { indices: [2, 3, 7, 6], color: '#ff0000', name: 'right' }, // Derecha (rojo)
        { indices: [1, 2, 6, 5], color: '#ffff00', name: 'down' },  // Abajo (amarillo)
        { indices: [0, 3, 7, 4], color: '#ffffff', name: 'up' }     // Arriba (blanco)
      ];

      // Parámetros de la cámara
      let rotationX = 0.5, rotationY = 0.7;
      let cameraDistance = 5;
      const fov = 1;
      let isDragging = false;
      let lastMouseX = 0, lastMouseY = 0;
      let targetRotationX = rotationX;
      let targetRotationY = rotationY;
      let startRotationX = rotationX;
      let startRotationY = rotationY;
      let animationStartTime = null;
      let isAnimating = false;
      const ANIMATION_DURATION = 300; // Duración para animaciones de vista

      // Versión 1.8: Corrige TypeError en rotateFaceStickers
      // Autor: Grok 3, creado por xAI
      // Fecha y Hora: 10:32 PM -03, Wednesday, June 25, 2025

      // Mapa de movimientos a nombres de caras
      const moveToFaceMap = {
        U: 'up',
        D: 'down',
        L: 'left',
        R: 'right',
        F: 'front',
        B: 'back'
      };

      // Mapa de adyacencias de caras
      const faceAdjacencies = {
        front: {
          clockwise: [['up', [6, 7, 8]], ['right', [0, 3, 6]], ['down', [2, 1, 0]], ['left', [8, 5, 2]]],
          counterClockwise: [['up', [6, 7, 8]], ['left', [8, 5, 2]], ['down', [2, 1, 0]], ['right', [0, 3, 6]]]
        },
        back: {
          clockwise: [['up', [2, 1, 0]], ['left', [0, 3, 6]], ['down', [6, 7, 8]], ['right', [8, 5, 2]]],
          counterClockwise: [['up', [2, 1, 0]], ['right', [8, 5, 2]], ['down', [6, 7, 8]], ['left', [0, 3, 6]]]
        },
        left: {
          clockwise: [['up', [0, 3, 6]], ['front', [0, 3, 6]], ['down', [0, 3, 6]], ['back', [8, 5, 2]]],
          counterClockwise: [['up', [0, 3, 6]], ['back', [8, 5, 2]], ['down', [0, 3, 6]], ['front', [0, 3, 6]]]
        },
        right: {
          clockwise: [['up', [8, 5, 2]], ['back', [0, 3, 6]], ['down', [8, 5, 2]], ['front', [8, 5, 2]]],
          counterClockwise: [['up', [8, 5, 2]], ['front', [8, 5, 2]], ['down', [8, 5, 2]], ['back', [0, 3, 6]]]
        },
        up: {
          clockwise: [['back', [0, 1, 2]], ['right', [0, 1, 2]], ['front', [0, 1, 2]], ['left', [0, 1, 2]]],
          counterClockwise: [['back', [0, 1, 2]], ['left', [0, 1, 2]], ['front', [0, 1, 2]], ['right', [0, 1, 2]]]
        },
        down: {
          clockwise: [['front', [6, 7, 8]], ['right', [6, 7, 8]], ['back', [6, 7, 8]], ['left', [6, 7, 8]]],
          counterClockwise: [['front', [6, 7, 8]], ['left', [6, 7, 8]], ['back', [6, 7, 8]], ['right', [6, 7, 8]]]
        }
      };

      // Reordenamiento de stickers
      const reorderMapClockwise = { 0: 6, 1: 3, 2: 0, 3: 7, 4: 4, 5: 1, 6: 8, 7: 5, 8: 2 };
      const reorderMapCounterClockwise = { 0: 2, 1: 5, 2: 8, 3: 1, 4: 4, 5: 7, 6: 0, 7: 3, 8: 6 };

      function rotateFaceStickers(faceName, direction) {
        const faceStickers = estadoCubo[faceName];
        if (!faceStickers) {
          console.error(`Invalid faceName: ${faceName}`);
          return;
        }
        const reorderMap = direction === 'clockwise' ? reorderMapClockwise : reorderMapCounterClockwise;
        const tempStickers = [...faceStickers];
        for (let i = 0; i < 9; i++) {
          faceStickers[i].color = tempStickers[reorderMap[i]].color;
        }
      }

      function rotateAdjacentStickers(faceName, direction) {
        const adjacencies = faceAdjacencies[faceName];
        if (!adjacencies) {
          console.error(`No adjacencies for face: ${faceName}`);
          return;
        }
        const tempColors = adjacencies[direction][0][1].map(idx => estadoCubo[adjacencies[direction][0][0]][idx].color);
        for (let i = 0; i < adjacencies[direction].length; i++) {
          const currentFace = adjacencies[direction][i][0];
          const currentIndices = adjacencies[direction][i][1];
          const nextFace = adjacencies[direction][(i + 1) % adjacencies[direction].length][0];
          const nextIndices = adjacencies[direction][(i + 1) % adjacencies[direction].length][1];
          if (i === adjacencies[direction].length - 1) {
            currentIndices.forEach((idx, j) => {
              estadoCubo[currentFace][idx].color = tempColors[j];
            });
          } else {
            currentIndices.forEach((idx, j) => {
              estadoCubo[currentFace][idx].color = estadoCubo[nextFace][nextIndices[j]].color;
            });
          }
        }
      }

      function rotateFace(faceName, direction) {
        if (isAnimating) return;
        isAnimating = true;
        rotateFaceStickers(faceName, direction);
        rotateAdjacentStickers(faceName, direction);
        drawCube();
        isAnimating = false;
      }

      function rotateMiddleLayer(layerType, direction) {
        if (isAnimating) return;
        isAnimating = true;
        const adjacencies = {
          M: {
            clockwise: [['up', [1, 4, 7]], ['front', [1, 4, 7]], ['down', [1, 4, 7]], ['back', [1, 4, 7]]],
            counterClockwise: [['up', [1, 4, 7]], ['back', [1, 4, 7]], ['down', [1, 4, 7]], ['front', [1, 4, 7]]]
          },
          E: {
            clockwise: [['front', [3, 4, 5]], ['right', [3, 4, 5]], ['back', [3, 4, 5]], ['left', [3, 4, 5]]],
            counterClockwise: [['front', [3, 4, 5]], ['left', [3, 4, 5]], ['back', [3, 4, 5]], ['right', [3, 4, 5]]]
          },
          S: {
            clockwise: [['up', [3, 4, 5]], ['right', [1, 4, 7]], ['down', [5, 4, 3]], ['left', [7, 4, 1]]],
            counterClockwise: [['up', [3, 4, 5]], ['left', [7, 4, 1]], ['down', [5, 4, 3]], ['right', [1, 4, 7]]]
          }
        }[layerType];
        const tempColors = adjacencies[direction][0][1].map(idx => estadoCubo[adjacencies[direction][0][0]][idx].color);
        for (let i = 0; i < adjacencies[direction].length; i++) {
          const currentFace = adjacencies[direction][i][0];
          const currentIndices = adjacencies[direction][i][1];
          const nextFace = adjacencies[direction][(i + 1) % adjacencies[direction].length][0];
          const nextIndices = adjacencies[direction][(i + 1) % adjacencies[direction].length][1];
          if (i === adjacencies.length - 1) {
            currentIndices.forEach((idx, j) => {
              estadoCubo[currentFace][idx].color = tempColors[j];
            });
          } else {
            currentIndices.forEach((idx, j) => {
              estadoCubo[currentFace][idx].color = estadoCubo[nextFace][nextIndices[j]].color;
            });
          }
        }
        drawCube();
        isAnimating = false;
      }

      function rotateCube(axis, direction) {
        if (isAnimating) return;
        isAnimating = true;
        const tempCubeState = JSON.parse(JSON.stringify(estadoCubo));
        let newFaceMapping = {};
        if (axis === 'x') {
          if (direction === 'clockwise') {
            newFaceMapping = {
              front: tempCubeState.down,
              down: tempCubeState.back,
              back: tempCubeState.up,
              up: tempCubeState.front,
              left: tempCubeState.left,
              right: tempCubeState.right
            };
            rotateFaceStickers('left', 'counterClockwise');
            rotateFaceStickers('right', 'clockwise');
          } else {
            newFaceMapping = {
              front: tempCubeState.up,
              up: tempCubeState.back,
              back: tempCubeState.down,
              down: tempCubeState.front,
              left: tempCubeState.left,
              right: tempCubeState.right
            };
            rotateFaceStickers('left', 'clockwise');
            rotateFaceStickers('right', 'counterClockwise');
          }
        } else if (axis === 'y') {
          if (direction === 'clockwise') {
            newFaceMapping = {
              front: tempCubeState.right,
              right: tempCubeState.back,
              back: tempCubeState.left,
              left: tempCubeState.front,
              up: tempCubeState.up,
              down: tempCubeState.down
            };
            rotateFaceStickers('up', 'clockwise');
            rotateFaceStickers('down', 'counterClockwise');
          } else {
            newFaceMapping = {
              front: tempCubeState.left,
              left: tempCubeState.back,
              back: tempCubeState.right,
              right: tempCubeState.front,
              up: tempCubeState.up,
              down: tempCubeState.down
            };
            rotateFaceStickers('up', 'counterClockwise');
            rotateFaceStickers('down', 'clockwise');
          }
        } else if (axis === 'z') {
          if (direction === 'clockwise') {
            newFaceMapping = {
              up: tempCubeState.left,
              left: tempCubeState.down,
              down: tempCubeState.right,
              right: tempCubeState.up,
              front: tempCubeState.front,
              back: tempCubeState.back
            };
            rotateFaceStickers('front', 'clockwise');
            rotateFaceStickers('back', 'counterClockwise');
          } else {
            newFaceMapping = {
              up: tempCubeState.right,
              right: tempCubeState.down,
              down: tempCubeState.left,
              left: tempCubeState.up,
              front: tempCubeState.front,
              back: tempCubeState.back
            };
            rotateFaceStickers('front', 'counterClockwise');
            rotateFaceStickers('back', 'clockwise');
          }
        }
        for (const faceName in newFaceMapping) {
          estadoCubo[faceName] = newFaceMapping[faceName];
        }
        drawCube();
        isAnimating = false;
      }

      controlsContainer.addEventListener('click', (e) => {
        const button = e.target.closest('button[data-move]');
        if (button) {
          const move = button.dataset.move;
          const [moveType, prime] = move.split('_');
          const direction = prime === 'prime' ? 'counterClockwise' : 'clockwise';
          switch (moveType) {
            case 'U': case 'D': case 'L': case 'R': case 'F': case 'B':
              const faceName = moveToFaceMap[moveType];
              if (faceName) {
                rotateFace(faceName, direction);
              } else {
                console.error(`Invalid moveType: ${moveType}`);
              }
              break;
            case 'M': case 'E': case 'S':
              rotateMiddleLayer(moveType, direction);
              break;
            case 'x': case 'y': case 'z':
              rotateCube(moveType, direction);
              break;
          }
        }
      });

      function rotarVector([x, y, z]) {
        let newX = x * Math.cos(rotationY) - z * Math.sin(rotationY);
        let newZ = x * Math.sin(rotationY) + z * Math.cos(rotationY);
        let newY = y * Math.cos(rotationX) - newZ * Math.sin(rotationX);
        newZ = y * Math.sin(rotationX) + newZ * Math.cos(rotationX);
        return [newX, newY, newZ];
      }

      function productoEscalar(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
      }

      function detectarCaraFrontal() {
        const camara = [0, 0, -1];
        let maxDot = -Infinity;
        let caraVisible = null;
        for (const nombre in normalesOriginales) {
          const rotada = rotarVector(normalesOriginales[nombre]);
          const dot = productoEscalar(rotada, camara);
          if (dot > maxDot) {
            maxDot = dot;
            caraVisible = nombre;
          }
        }
        return caraVisible;
      }

      function normalizeAngle(angle) {
        while (angle > Math.PI) angle -= 2 * Math.PI;
        while (angle < -Math.PI) angle += 2 * Math.PI;
        return angle;
      }

      function animateToFace(faceName) {
        const target = angulosObjetivo[faceName];
        startRotationX = rotationX;
        startRotationY = rotationY;
        targetRotationX = target.rotationX;
        targetRotationY = normalizeAngle(target.rotationY);
        if (Math.abs(targetRotationY - startRotationY) > Math.PI) {
          if (targetRotationY > startRotationY) {
            targetRotationY -= 2 * Math.PI;
          } else {
            targetRotationY += 2 * Math.PI;
          }
        }
        animationStartTime = performance.now();
        isAnimating = true;
        requestAnimationFrame(animate);
      }

      function animate() {
        if (isAnimating) {
          const currentTime = performance.now();
          const elapsed = Math.min((currentTime - animationStartTime) / ANIMATION_DURATION, 1);
          const t = elapsed;
          rotationX = startRotationX + (targetRotationX - startRotationX) * t;
          rotationY = startRotationY + (targetRotationY - startRotationY) * t;
          if (elapsed >= 1) {
            isAnimating = false;
            rotationX = targetRotationX;
            rotationY = targetRotationY;
          }
          drawCube();
          if (isAnimating) requestAnimationFrame(animate);
        }
      }

      function project(vertex) {
        const [x, y, z] = vertex;
        const zAdjusted = z + cameraDistance;
        if (zAdjusted <= 0) return [0, 0];
        const factor = fov / zAdjusted;
        const scale = Math.min(canvas.width, canvas.height) * 0.3;
        return [
          x * factor * scale + canvas.width / 2,
          -y * factor * scale + canvas.height / 2
        ];
      }

      function rotateVertex([x, y, z]) {
        let newX = x * Math.cos(rotationY) - z * Math.sin(rotationY);
        let newZ = x * Math.sin(rotationY) + z * Math.cos(rotationY);
        let newY = y * Math.cos(rotationX) - newZ * Math.sin(rotationX);
        newZ = y * Math.sin(rotationX) + newZ * Math.cos(rotationX);
        return [newX, newY, newZ];
      }

      function getGridPoints(v0, v1, v2, v3) {
        const points = [];
        for (let i = 0; i <= 3; i++) {
          const t = i / 3;
          const p0 = [(1 - t) * v0[0] + t * v1[0], (1 - t) * v0[1] + t * v1[1]];
          const p1 = [(1 - t) * v3[0] + t * v2[0], (1 - t) * v3[1] + t * v2[1]];
          for (let j = 0; j <= 3; j++) {
            const s = j / 3;
            points.push([(1 - s) * p0[0] + s * p1[0], (1 - s) * p0[1] + s * p1[1]]);
          }
        }
        return points;
      }

      function drawFace(face, vertices2D) {
        const [v0, v1, v2, v3] = vertices2D;
        const points = getGridPoints(v0, v1, v2, v3);
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            const idx = i * 4 + j;
            const p0 = points[idx];
            const p1 = points[idx + 1];
            const p2 = points[idx + 5];
            const p3 = points[idx + 4];
            const stickerIndex = i * 3 + j;
            const sticker = estadoCubo[face.name][stickerIndex];
            ctx.beginPath();
            ctx.moveTo(p0[0], p0[1]);
            ctx.lineTo(p1[0], p1[1]);
            ctx.lineTo(p2[0], p2[1]);
            ctx.lineTo(p3[0], p3[1]);
            ctx.closePath();
            ctx.fillStyle = sticker.color;
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        }
      }

      function drawCube() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const projectedFaces = faces.map(face => {
          const vertices3D = face.indices.map(i => rotateVertex(vertices[i]));
          const avgZ = vertices3D.reduce((sum, v) => sum + v[2], 0) / 4;
          return { face, vertices2D: vertices3D.map(project), avgZ };
        }).sort((a, b) => b.avgZ - a.avgZ);
        projectedFaces.forEach(({ face, vertices2D }) => {
          drawFace(face, vertices2D);
        });
        const caraFrontal = detectarCaraFrontal();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Arial';
        ctx.fillText(`Cara visible: ${caraFrontal.toUpperCase()}`, 20, canvas.height - 20);
      }

      canvas.addEventListener('mousedown', e => {
        if (!isAnimating) {
          isDragging = true;
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
        }
      });

      canvas.addEventListener('mousemove', e => {
        if (isDragging && !isAnimating) {
          const dx = e.clientX - lastMouseX;
          const dy = e.clientY - lastMouseY;
          rotationY += dx * 0.005;
          rotationX += dy * 0.005;
          rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationX));
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
          drawCube();
        }
      });

      canvas.addEventListener('mouseup', () => isDragging = false);
      canvas.addEventListener('mouseleave', () => isDragging = false);

      canvas.addEventListener('wheel', e => {
        if (!isAnimating) {
          e.preventDefault();
          cameraDistance += e.deltaY * 0.01;
          cameraDistance = Math.max(3, Math.min(10, cameraDistance));
          drawCube();
        }
      });

      faceSelector.addEventListener('change', () => {
        animateToFace(faceSelector.value);
      });

      drawCube();
    });
  </script>
</body>
</html>
