<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cubo Rubik - V2.0 con Log en UI</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body, html {
      background: #111;
      color: #fff;
      font-family: Arial, Helvetica, sans-serif;
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    canvas {
      display: block;
      flex-shrink: 0;
    }
    #main-container {
        display: flex;
        width: 100%;
        height: 100%;
        align-items: flex-start;
        padding: 10px;
    }
    #info {
      position: fixed;
      top: 10px;
      left: 10px;
      padding: 8px 12px;
      background: rgba(0,0,0,0.6);
      border-radius: 8px;
      font-size: 14px;
      z-index: 10;
    }
    #controls-container {
      position: relative;
      top: 0;
      left: 0;
      padding: 10px;
      background: rgba(0,0,0,0.6);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 95vh;
      overflow-y: auto;
      margin-right: 10px;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .control-group label {
      font-size: 14px;
      margin-bottom: 5px;
    }
    .control-group select, .control-group button {
      padding: 5px 10px;
      margin: 2px;
      background: rgba(255,255,255,0.1);
      border: none;
      border-radius: 3px;
      color: #fff;
      font-family: Arial;
      font-size: 14px;
      cursor: pointer;
    }
    .control-group button:hover {
      background: rgba(255,255,255,0.2);
    }
    .control-group select {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.3);
    }
    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }
    #ui-container {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
    }
    #log-container {
        border: 1px solid #333;
        background-color: #0A0A0A;
        color: #00FF41;
        font-family: 'Consolas', 'Monaco', 'Lucida Console', monospace;
        font-size: 12px;
        height: 30%;
        overflow-y: scroll;
        padding: 10px;
        white-space: pre-wrap;
        word-wrap: break-word;
        flex-grow: 1;
        margin-top: 10px;
        border-radius: 5px;
    }
    .log-entry {
        margin: 0;
        padding: 0;
        line-height: 1.4;
    }
    .log-INFO {
        color: #00FF41; /* Verde */
    }
    .log-VERBOSE {
        color: #888; /* Gris */
    }
    .log-SUCCESS {
        color: #50E3C2; /* Turquesa */
    }
    .log-ERROR {
        color: #FF4136; /* Rojo */
    }
  </style>
</head>
<body>
  <div id="info">
    Arrastra con el ratón para girar el cubo · Usa la rueda para hacer <em>zoom</em>
  </div>
  <div id="main-container">
    <div id="controls-container">
        <div class="control-group">
            <label for="faceSelector">Seleccionar Cara:</label>
            <select id="faceSelector">
                <option value="front">Front (F)</option>
                <option value="back">Back (B)</option>
                <option value="left">Left (L)</option>
                <option value="right">Right (R)</option>
                <option value="up">Up (U)</option>
                <option value="down">Down (D)</option>
            </select>
        </div>
        <div class="control-group">
            <label>Movimientos de Cara:</label>
            <div class="button-row">
                <button data-move="U">U</button> <button data-move="U_prime">U'</button>
                <button data-move="D">D</button> <button data-move="D_prime">D'</button>
                <button data-move="L">L</button> <button data-move="L_prime">L'</button>
                <button data-move="R">R</button> <button data-move="R_prime">R'</button>
                <button data-move="F">F</button> <button data-move="F_prime">F'</button>
                <button data-move="B">B</button> <button data-move="B_prime">B'</button>
            </div>
        </div>
        <div class="control-group">
            <label>Movimientos de Capa Media:</label>
            <div class="button-row">
                <button data-move="M">M</button> <button data-move="M_prime">M'</button>
                <button data-move="E">E</button> <button data-move="E_prime">E'</button>
                <button data-move="S">S</button> <button data-move="S_prime">S'</button>
            </div>
        </div>
        <div class="control-group">
            <label>Rotaciones de Cubo Completo:</label>
            <div class="button-row">
                <button data-move="x">x</button> <button data-move="x_prime">x'</button>
                <button data-move="y">y</button> <button data-move="y_prime">y'</button>
                <button data-move="z">z</button> <button data-move="z_prime">z'</button>
            </div>
        </div>
        <div class="control-group">
            <div class="button-row">
                <button id="scrambleButton">Mezclar</button>
                <button id="solveButton">Resolver</button>
            </div>
        </div>
        <div class="control-group">
            <label for="logLevelSelector">Nivel de Log:</label>
            <select id="logLevelSelector">
                <option value="NONE">Ninguno</option>
                <option value="INFO" selected>Informativo</option>
                <option value="VERBOSE">Detallado</option>
            </select>
        </div>
    </div>
    <div id="ui-container">
        <canvas id="canvas"></canvas>
        <div id="log-container"></div>
    </div>
  </div>

  <script src="libs/cube.js"></script>
  <script src="libs/solve.js"></script>
  <script>
    window.addEventListener('load', () => {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const faceSelector = document.getElementById('faceSelector');
      const controlsContainer = document.getElementById('controls-container');
      const scrambleButton = document.getElementById('scrambleButton');
      const solveButton = document.getElementById('solveButton');
      const logLevelSelector = document.getElementById('logLevelSelector');
      const logContainer = document.getElementById('log-container');

      let scrambleMoves = [];
      
      function resizeCanvas() {
        const container = document.getElementById('ui-container');
        const availableHeight = container.clientHeight - logContainer.clientHeight - 20; // 20px for margin
        const size = Math.min(container.clientWidth, availableHeight);
        canvas.width = size;
        canvas.height = size;
      }
      
      window.addEventListener('resize', resizeCanvas);

      function logToScreen(message, level = 'INFO') {
          const logEntry = document.createElement('p');
          logEntry.className = `log-entry log-${level}`;
          logEntry.textContent = `> ${message}`;
          logContainer.appendChild(logEntry);
          logContainer.scrollTop = logContainer.scrollHeight;
      }

      const logger = {
          log: logToScreen,
          clear: () => { logContainer.innerHTML = ''; }
      };

      const estadoCubo = {
        front: Array(9).fill({ color: '#00ff00' }),
        back: Array(9).fill({ color: '#0000ff' }),
        left: Array(9).fill({ color: '#ffa500' }),
        right: Array(9).fill({ color: '#ff0000' }),
        up: Array(9).fill({ color: '#ffffff' }),
        down: Array(9).fill({ color: '#ffff00' })
      };

      const normalesOriginales = {
        front: [0, 0, 1], back: [0, 0, -1], left: [-1, 0, 0],
        right: [1, 0, 0], up: [0, 1, 0], down: [0, -1, 0]
      };

      const angulosObjetivo = {
        front: { rotationX: 0, rotationY: 0 },
        back: { rotationX: 0, rotationY: Math.PI },
        left: { rotationX: 0, rotationY: -Math.PI / 2 },
        right: { rotationX: 0, rotationY: Math.PI / 2 },
        up: { rotationX: -Math.PI / 2, rotationY: 0 },
        down: { rotationX: Math.PI / 2, rotationY: 0 }
      };

      const vertices = [
        [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
        [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
      ];

      const faces = [
        { indices: [0, 1, 2, 3], name: 'back' }, { indices: [4, 5, 6, 7], name: 'front' },
        { indices: [0, 1, 5, 4], name: 'left' }, { indices: [2, 3, 7, 6], name: 'right' },
        { indices: [1, 2, 6, 5], name: 'down' }, { indices: [0, 3, 7, 4], name: 'up' }
      ];

      let rotationX = 0.5, rotationY = 0.7;
      let cameraDistance = 5;
      const fov = 1;
      let isDragging = false;
      let lastMouseX = 0, lastMouseY = 0;
      let isAnimating = false;
      const ANIMATION_DURATION = 300;

      const moveToFaceMap = {
        U: 'up', D: 'down', L: 'left', R: 'right', F: 'front', B: 'back'
      };

      const faceAdjacencies = {
        front: {
          clockwise: [['up', [6, 7, 8]], ['right', [0, 3, 6]], ['down', [2, 1, 0]], ['left', [8, 5, 2]]],
          counterClockwise: [['up', [6, 7, 8]], ['left', [8, 5, 2]], ['down', [2, 1, 0]], ['right', [0, 3, 6]]]
        },
        back: {
          clockwise: [['up', [2, 1, 0]], ['left', [0, 3, 6]], ['down', [6, 7, 8]], ['right', [8, 5, 2]]],
          counterClockwise: [['up', [2, 1, 0]], ['right', [8, 5, 2]], ['down', [6, 7, 8]], ['left', [0, 3, 6]]]
        },
        left: {
          clockwise: [['up', [0, 3, 6]], ['front', [0, 3, 6]], ['down', [0, 3, 6]], ['back', [8, 5, 2]]],
          counterClockwise: [['up', [0, 3, 6]], ['back', [8, 5, 2]], ['down', [0, 3, 6]], ['front', [0, 3, 6]]]
        },
        right: {
          clockwise: [['up', [8, 5, 2]], ['back', [0, 3, 6]], ['down', [8, 5, 2]], ['front', [8, 5, 2]]],
          counterClockwise: [['up', [8, 5, 2]], ['front', [8, 5, 2]], ['down', [8, 5, 2]], ['back', [0, 3, 6]]]
        },
        up: {
          clockwise: [['back', [0, 1, 2]], ['right', [0, 1, 2]], ['front', [0, 1, 2]], ['left', [0, 1, 2]]],
          counterClockwise: [['back', [0, 1, 2]], ['left', [0, 1, 2]], ['front', [0, 1, 2]], ['right', [0, 1, 2]]]
        },
        down: {
          clockwise: [['front', [6, 7, 8]], ['right', [6, 7, 8]], ['back', [6, 7, 8]], ['left', [6, 7, 8]]],
          counterClockwise: [['front', [6, 7, 8]], ['left', [6, 7, 8]], ['back', [6, 7, 8]], ['right', [6, 7, 8]]]
        }
      };

      const reorderMapClockwise = { 0: 2, 1: 5, 2: 8, 3: 1, 4: 4, 5: 7, 6: 0, 7: 3, 8: 6 };
      const reorderMapCounterClockwise = { 0: 6, 1: 3, 2: 0, 3: 7, 4: 4, 5: 1, 6: 8, 7: 5, 8: 2 };

      function rotateFaceStickers(faceName, direction) {
        const faceStickers = estadoCubo[faceName];
        const reorderMap = direction === 'clockwise' ? reorderMapClockwise : reorderMapCounterClockwise;
        const tempStickers = [...faceStickers];
        for (let i = 0; i < 9; i++) {
          faceStickers[i] = {color: tempStickers[reorderMap[i]].color};
        }
      }

      function rotateAdjacentStickers(faceName, direction) {
        const adjacencies = faceAdjacencies[faceName][direction];
        const tempColors = adjacencies[0][1].map(idx => estadoCubo[adjacencies[0][0]][idx].color);
        for (let i = 0; i < adjacencies.length; i++) {
          const [currentFace, currentIndices] = adjacencies[i];
          const [nextFace, nextIndices] = adjacencies[(i + 1) % adjacencies.length];
          if (i === adjacencies.length - 1) {
            currentIndices.forEach((idx, j) => {
              estadoCubo[currentFace][idx] = {color: tempColors[j]};
            });
          } else {
            currentIndices.forEach((idx, j) => {
              estadoCubo[currentFace][idx] = {color: estadoCubo[nextFace][nextIndices[j]].color};
            });
          }
        }
      }

      function rotateFace(faceName, direction) {
        rotateFaceStickers(faceName, direction);
        rotateAdjacentStickers(faceName, direction);
        drawCube();
      }

      function rotateMiddleLayer(layerType, direction) {
        const cycles = {
          M: { // Moves like L, but direction is from R to L (x-axis negative)
            clockwise: [['up', [1, 4, 7]], ['back', [7, 4, 1]], ['down', [1, 4, 7]], ['front', [1, 4, 7]]],
            counterClockwise: [['up', [1, 4, 7]], ['front', [1, 4, 7]], ['down', [1, 4, 7]], ['back', [7, 4, 1]]]
          },
          E: { // Moves like D, but direction is from U to D (y-axis negative)
            clockwise: [['front', [3, 4, 5]], ['left', [3, 4, 5]], ['back', [5, 4, 3]], ['right', [3, 4, 5]]],
            counterClockwise: [['front', [3, 4, 5]], ['right', [3, 4, 5]], ['back', [5, 4, 3]], ['left', [3, 4, 5]]]
          },
          S: { // Moves like F (z-axis positive)
            clockwise: [['up', [3, 4, 5]], ['right', [1, 4, 7]], ['down', [5, 4, 3]], ['left', [7, 4, 1]]],
            counterClockwise: [['up', [3, 4, 5]], ['left', [7, 4, 1]], ['down', [5, 4, 3]], ['right', [1, 4, 7]]]
          }
        }[layerType];

        const cycle = cycles[direction];
        const tempColors = cycle[0][1].map(idx => estadoCubo[cycle[0][0]][idx].color);

        for (let i = 0; i < cycle.length; i++) {
          const [currentFace, currentIndices] = cycle[i];
          const [nextFace, nextIndices] = cycle[(i + 1) % cycle.length];
          
          if (i === cycle.length - 1) {
            currentIndices.forEach((idx, j) => {
              estadoCubo[currentFace][idx] = {color: tempColors[j]};
            });
          } else {
            currentIndices.forEach((idx, j) => {
              estadoCubo[currentFace][idx] = {color: estadoCubo[nextFace][nextIndices[j]].color};
            });
          }
        }
        drawCube();
      }

      function rotateCube(axis, direction) {
        const tempCubeState = JSON.parse(JSON.stringify(estadoCubo));
        let newFaceMapping = {};

        if (axis === 'x') {
          if (direction === 'clockwise') {
            newFaceMapping = { front: tempCubeState.down, down: tempCubeState.back, back: tempCubeState.up, up: tempCubeState.front };
            rotateFaceStickers('left', 'counterClockwise');
            rotateFaceStickers('right', 'clockwise');
          } else {
            newFaceMapping = { front: tempCubeState.up, up: tempCubeState.back, back: tempCubeState.down, down: tempCubeState.front };
            rotateFaceStickers('left', 'clockwise');
            rotateFaceStickers('right', 'counterClockwise');
          }
        } else if (axis === 'y') {
          if (direction === 'clockwise') {
            newFaceMapping = { front: tempCubeState.right, right: tempCubeState.back, back: tempCubeState.left, left: tempCubeState.front };
            rotateFaceStickers('up', 'clockwise');
            rotateFaceStickers('down', 'counterClockwise');
          } else {
            newFaceMapping = { front: tempCubeState.left, left: tempCubeState.back, back: tempCubeState.right, right: tempCubeState.front };
            rotateFaceStickers('up', 'counterClockwise');
            rotateFaceStickers('down', 'clockwise');
          }
        } else if (axis === 'z') {
          if (direction === 'clockwise') {
            newFaceMapping = { up: tempCubeState.left, left: tempCubeState.down, down: tempCubeState.right, right: tempCubeState.up };
            rotateFaceStickers('front', 'clockwise');
            rotateFaceStickers('back', 'counterClockwise');
          } else {
            newFaceMapping = { up: tempCubeState.right, right: tempCubeState.down, down: tempCubeState.left, left: tempCubeState.up };
            rotateFaceStickers('front', 'counterClockwise');
            rotateFaceStickers('back', 'clockwise');
          }
        }
        
        Object.assign(estadoCubo, newFaceMapping);
        drawCube();
      }

      function executeMove(move) {
        let base = move;
        let times = 1;
        if (move.endsWith('2')) {
          base = move.slice(0, -1);
          times = 2;
        }
        const [moveType, prime] = base.split('_');
        const direction = prime === 'prime' ? 'counterClockwise' : 'clockwise';
        
        for (let i = 0; i < times; i++) {
            switch (moveType) {
                case 'U': case 'D': case 'L': case 'R': case 'F': case 'B':
                    rotateFace(moveToFaceMap[moveType], direction);
                    break;
                case 'M': case 'E': case 'S':
                    rotateMiddleLayer(moveType, direction);
                    break;
                case 'x': case 'y': case 'z':
                    rotateCube(moveType, direction);
                    break;
            }
        }
      }

      function applyMovesSequentially(moves, index = 0, callback) {
        if (index >= moves.length) {
          if (callback) callback();
          return;
        }
        executeMove(moves[index]);
        setTimeout(() => applyMovesSequentially(moves, index + 1, callback), 100);
      }

      function scrambleCube() {
        logger.clear();
        logger.log("Mezclando el cubo...", "INFO");
        const base = ['U','D','L','R','F','B'];
        scrambleMoves = [];
        for (let i = 0; i < 20; i++) {
          let m = base[Math.floor(Math.random() * base.length)];
          if (Math.random() < 0.5) m += '_prime';
          scrambleMoves.push(m);
        }
        applyMovesSequentially(scrambleMoves, 0, () => {
            logger.log(`Mezcla aplicada: ${scrambleMoves.join(" ")}`, "SUCCESS");
        });
      }

      function cubeStateToString() {
        const colorMap = {
          '#ffffff': 'U', '#ff0000': 'R', '#00ff00': 'F',
          '#ffff00': 'D', '#ffa500': 'L', '#0000ff': 'B'
        };
        const order = ['up', 'right', 'front', 'down', 'left', 'back'];
        let result = '';
        for (const face of order) {
          estadoCubo[face].forEach(s => {
            result += colorMap[s.color.toLowerCase()] || 'X';
          });
        }
        return result;
      }

      function isSolvedState() {
        const cube = Cube.fromString(cubeStateToString());
        return cube.isSolved();
      }

      function solveCube() {
        logger.clear();
        if (typeof Cube !== 'undefined' && Cube.setLogger) {
            Cube.setLogger(logger);
            Cube.setLogLevel(logLevelSelector.value);
        }
      
        const cube = Cube.fromString(cubeStateToString());
        const solution = cube.solve();

        if (!solution) {
          logger.log('No se pudo encontrar una solución.', 'ERROR');
          return;
        }
        const moves = solution.split(' ').map(m => m.replace("'", '_prime'));
        applyMovesSequentially(moves, 0, () => {
          logger.log(isSolvedState() ? '¡Cubo resuelto!' : 'La resolución falló', 'SUCCESS');
        });
      }

      controlsContainer.addEventListener('click', (e) => {
        const button = e.target.closest('button[data-move]');
        if (button) {
          executeMove(button.dataset.move);
        }
      });

      scrambleButton.addEventListener('click', scrambleCube);
      solveButton.addEventListener('click', solveCube);
      
      // Prepara el resolutor calculando las tablas de movimientos y poda.
      Cube.initSolver();

      function drawCube() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const projectedFaces = faces.map(face => {
          const vertices3D = face.indices.map(i => rotateVertex(vertices[i]));
          const avgZ = vertices3D.reduce((sum, v) => sum + v[2], 0) / 4;
          return { face, vertices2D: vertices3D.map(project), avgZ };
        }).sort((a, b) => b.avgZ - a.avgZ);
        
        projectedFaces.forEach(({ face, vertices2D }) => {
          drawFace(face, vertices2D);
        });
      }

      function drawFace(face, vertices2D) {
        const [v0, v1, v2, v3] = vertices2D;
        const points = getGridPoints(v0, v1, v2, v3);
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            const idx = i * 4 + j;
            const p0 = points[idx], p1 = points[idx + 1], p2 = points[idx + 5], p3 = points[idx + 4];
            const stickerIndex = i * 3 + j;
            const sticker = estadoCubo[face.name][stickerIndex];
            ctx.beginPath();
            ctx.moveTo(p0[0], p0[1]);
            ctx.lineTo(p1[0], p1[1]);
            ctx.lineTo(p2[0], p2[1]);
            ctx.lineTo(p3[0], p3[1]);
            ctx.closePath();
            ctx.fillStyle = sticker.color;
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        }
      }

      function rotateVertex([x, y, z]) {
        let newX = x * Math.cos(rotationY) - z * Math.sin(rotationY);
        let newZ = x * Math.sin(rotationY) + z * Math.cos(rotationY);
        let newY = y * Math.cos(rotationX) - newZ * Math.sin(rotationX);
        newZ = y * Math.sin(rotationX) + newZ * Math.cos(rotationX);
        return [newX, newY, newZ];
      }

      function project(vertex) {
        const [x, y, z] = vertex;
        const zAdjusted = z + cameraDistance;
        if (zAdjusted <= 0) return [0, 0];
        const factor = fov / zAdjusted;
        const scale = Math.min(canvas.width, canvas.height) * 0.8;
        return [
          x * factor * scale + canvas.width / 2,
          -y * factor * scale + canvas.height / 2
        ];
      }

      function getGridPoints(v0, v1, v2, v3) {
        const points = [];
        for (let i = 0; i <= 3; i++) {
          const t = i / 3;
          const p0 = [(1 - t) * v0[0] + t * v1[0], (1 - t) * v0[1] + t * v1[1]];
          const p1 = [(1 - t) * v3[0] + t * v2[0], (1 - t) * v3[1] + t * v2[1]];
          for (let j = 0; j <= 3; j++) {
            const s = j / 3;
            points.push([(1 - s) * p0[0] + s * p1[0], (1 - s) * p0[1] + s * p1[1]]);
          }
        }
        return points;
      }

      canvas.addEventListener('mousedown', e => { isDragging = true; lastMouseX = e.clientX; lastMouseY = e.clientY; });
      canvas.addEventListener('mousemove', e => {
        if (isDragging) {
          const dx = e.clientX - lastMouseX;
          const dy = e.clientY - lastMouseY;
          rotationY += dx * 0.005;
          rotationX += dy * 0.005;
          rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationX));
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
          drawCube();
        }
      });
      canvas.addEventListener('mouseup', () => isDragging = false);
      canvas.addEventListener('mouseleave', () => isDragging = false);
      canvas.addEventListener('wheel', e => {
        e.preventDefault();
        cameraDistance += e.deltaY * 0.01;
        cameraDistance = Math.max(3, Math.min(10, cameraDistance));
        drawCube();
      });

      resizeCanvas();
      drawCube();
    });
  </script>
</body>
</html>
